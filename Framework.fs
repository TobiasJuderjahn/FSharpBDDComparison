module FsharpBDDComparison.Framework

open System
open System.Globalization

[<AutoOpen>]
module TypeExtensions =
    type DateTime with
        /// Returns 2020-04-08T11:55:00 for both "2020-04-08T11:55:00+02" and "2020-04-08T11:55:00Z"
        static member ParseUtcIso(dateTimeString:string) =
            DateTime.Parse(dateTimeString, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind)

        static member ToStringIso(dt:DateTime) =
            dt.ToString("yyyy-MM-ddTHH:mm:ss.fffZ")


module Table =
    module VTable = 
        let getValueByKey key (rows: string[][]) = 
            rows
            |> Array.tryFind (fun x -> x.[0] = key)
            |> function
            | Some value -> value.[1]
            | None -> failwithf $"Could not find value of key %s{key}!"

        let getValueByKeyOrNone key (rows: string[][]) =
            rows
            |> Array.tryFind (fun x -> x.[0] = key)
            |> Option.map (fun x -> x.[1])

        let getValueByKeyOrDefault key defaultValue (rows: string[][]) =
            rows
            |> getValueByKeyOrNone key
            |> Option.defaultValue defaultValue
            
        let replacePlaceholders (table: string[][]) (stringWithPlaceholders:string) : string =
            table
            |> Array.fold (fun (state:string) (rowValues:string[]) ->
                state.Replace(
                    $"{{%s{rowValues.[0]}}}",
                    (getValueByKey rowValues.[0] table))) stringWithPlaceholders
            
// This will not be needed once https://github.com/fsprojects/TickSpec/pull/48 is merged
module TickSpec =
    open System.Collections.Generic
    open Xunit.Abstractions
    open TickSpec

    type XunitSerializableScenario =
        val mutable FeatureName : string
        val mutable Name : string
        val mutable Parameters: (string*string)[]
        val mutable Tags: string[]
        new (featureName: string, name: string, parameters: (string*string)[], tags: string[]) = { FeatureName = featureName; Name = name; Parameters = parameters; Tags = tags }
        
        override this.ToString() =
            if this.Parameters.Length = 0 && this.Tags.Length = 0 then this.Name
            else
                let parameters =  this.Parameters |> Array.map (fun (k,v) -> $"{k}={v}") |> String.concat ","
                let tags =  this.Tags |> String.concat ","
                sprintf "%s<%s>{%s}" this.Name tags parameters

        interface IXunitSerializable with
            member this.Serialize (info:IXunitSerializationInfo) =
                info.AddValue("FeatureName", this.FeatureName)
                info.AddValue("Name", this.Name)
                info.AddValue("Parameters", this.Parameters |> Array.map (fun (k,v) -> $"{k}={v}"))       
                info.AddValue("Tags", this.Tags)
                
            member this.Deserialize(info:IXunitSerializationInfo) =
                let featureName = info.GetValue<string>("FeatureName")
                let name = info.GetValue<string>("Name")
                let parameters =
                    info.GetValue<string[]>("Parameters")
                    |> Array.map (fun kv ->
                        let kva = kv.Split("=")
                        kva.[0], kva.[1])
                let tags = info.GetValue<string[]>("Tags")
                this.FeatureName <- featureName
                this.Name <- name
                this.Parameters <- parameters
                this.Tags <- tags
                
    /// Represents a set of Step Definitions available within a given Assembly
    type AssemblyStepDefinitionsSource(assembly : System.Reflection.Assembly) =
        let definitions = StepDefinitions(assembly)
        let scenarioActions : Dictionary<string, Action> = Dictionary<string, Action>() 

        let createScenarioActionsKey featureName scenarioName = $"{featureName}/{scenarioName}" 
        
        /// Yields Scenarios generated by parsing the supplied Resource Name and binding the steps to their Step Definitions
        member __.ScenariosFromEmbeddedResource resourceName : XunitSerializableScenario seq =
            let stream = assembly.GetManifestResourceStream(resourceName)
            let scenarios = definitions.GenerateScenarios(resourceName, stream)
            scenarios
            |> Seq.iter (fun s ->
                scenarioActions.[createScenarioActionsKey resourceName s.Name] <- s.Action)
            
            scenarios
            |> Seq.map (fun s ->
                XunitSerializableScenario (resourceName, s.Name, s.Parameters, s.Tags))

        member __.ScenarioAction(scenario: XunitSerializableScenario) : Action =
            scenarioActions.[createScenarioActionsKey scenario.FeatureName scenario.Name]

    /// Adapts a Scenario Sequence to match the required format for an xUnit MemberData attribute
    module MemberData =
        let ofScenarios xs = xs |> Seq.map (fun x -> [| x |])

    